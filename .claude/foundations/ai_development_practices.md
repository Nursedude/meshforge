# MeshForge AI Development Practices

> Best Practices for AI-Assisted Software Development
> Security | Code Quality | Debugging | Infrastructure Review

---

## Overview

This guide establishes standards for leveraging AI assistants in software development, specifically tailored for mesh networking, RF systems, and distributed infrastructure. It serves as both a training resource for AI assistants and an educational guide for developers.

```
┌─────────────────────────────────────────────────────────────────┐
│              AI-ASSISTED DEVELOPMENT LIFECYCLE                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐     │
│   │ DESIGN  │───▶│  CODE   │───▶│  DEBUG  │───▶│ REVIEW  │     │
│   │         │    │         │    │         │    │         │     │
│   └────┬────┘    └────┬────┘    └────┬────┘    └────┬────┘     │
│        │              │              │              │           │
│    AI: Context    AI: Generate   AI: Analyze    AI: Audit      │
│    Understanding  & Implement    & Fix          & Optimize     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Part 1: AI Coding Principles

### 1.1 Context-First Development

Before writing any code, AI assistants must establish comprehensive context:

```
CONTEXT GATHERING CHECKLIST
═══════════════════════════

□ Project Structure
  - Directory layout
  - Module organization
  - Existing patterns

□ Technology Stack
  - Languages and versions
  - Frameworks in use
  - External dependencies

□ Coding Standards
  - Style conventions
  - Naming patterns
  - Documentation requirements

□ Domain Knowledge
  - Mesh networking concepts
  - RF/radio fundamentals
  - Protocol specifications

□ Security Requirements
  - Authentication patterns
  - Data protection needs
  - Compliance requirements
```

### 1.2 Code Generation Standards

**Principle: Generate code that humans can understand, maintain, and trust.**

```python
# AI CODE GENERATION TEMPLATE

"""
Module: [Name]
Purpose: [Clear one-line description]
Dependencies: [List key imports]
Security: [Note any security considerations]

AI Generation Notes:
- Generated by: [AI model/version]
- Context: [What prompted this generation]
- Confidence: [High/Medium/Low]
- Human Review: [Required/Recommended/Optional]
"""

# GOOD: Clear, documented, follows project patterns
class MeshNodeHandler:
    """
    Handles mesh node discovery and communication.

    This class manages connections to Meshtastic nodes,
    providing a clean interface for message handling.

    Attributes:
        node_id: Unique identifier for this handler
        connection: Active serial/TCP connection

    Security Note:
        Validates all incoming messages before processing.
    """

    def __init__(self, node_id: str, connection: Connection):
        self.node_id = self._validate_node_id(node_id)
        self.connection = connection
        self._message_queue = queue.Queue()

    def _validate_node_id(self, node_id: str) -> str:
        """Validate and sanitize node ID."""
        if not node_id or not re.match(r'^[a-f0-9]{8}$', node_id):
            raise ValueError(f"Invalid node ID format: {node_id}")
        return node_id
```

### 1.3 Security-First Code Generation

AI must prioritize security in all generated code:

```python
# SECURITY PATTERNS FOR AI-GENERATED CODE

# 1. INPUT VALIDATION - Always validate external input
def process_user_input(data: str) -> dict:
    """Process and validate user input."""
    # Validate type
    if not isinstance(data, str):
        raise TypeError("Input must be string")

    # Validate length
    if len(data) > MAX_INPUT_LENGTH:
        raise ValueError("Input exceeds maximum length")

    # Sanitize content
    sanitized = bleach.clean(data)

    return {"content": sanitized, "validated": True}


# 2. COMMAND INJECTION PREVENTION
def execute_system_command(command: str, args: List[str]) -> str:
    """Execute system command safely."""
    # Whitelist allowed commands
    ALLOWED_COMMANDS = {'meshtastic', 'rnsd', 'ip', 'ping'}

    if command not in ALLOWED_COMMANDS:
        raise SecurityError(f"Command not allowed: {command}")

    # Use subprocess with shell=False
    result = subprocess.run(
        [command] + args,
        shell=False,  # CRITICAL: Never shell=True with user input
        capture_output=True,
        text=True,
        timeout=30
    )
    return result.stdout


# 3. PATH TRAVERSAL PREVENTION
def read_config_file(filename: str) -> dict:
    """Read configuration file safely."""
    # Validate filename
    if '..' in filename or filename.startswith('/'):
        raise SecurityError("Invalid filename")

    # Resolve to absolute path within allowed directory
    config_dir = Path.home() / '.config' / 'meshforge'
    safe_path = (config_dir / filename).resolve()

    # Verify path is within allowed directory
    if not str(safe_path).startswith(str(config_dir)):
        raise SecurityError("Path traversal detected")

    return json.loads(safe_path.read_text())


# 4. SQL INJECTION PREVENTION (if using databases)
def get_node_by_id(node_id: str) -> Optional[Node]:
    """Get node from database safely."""
    # Always use parameterized queries
    query = "SELECT * FROM nodes WHERE node_id = ?"
    result = db.execute(query, (node_id,))  # Parameterized!
    return result.fetchone()
```

### 1.4 RF/Mesh-Specific Coding Patterns

```python
# MESH NETWORKING PATTERNS

class MeshMessage:
    """
    Represents a message in the mesh network.

    RF Considerations:
    - Keep payloads small (LoRa has limited bandwidth)
    - Include hop count for network analysis
    - Timestamp for latency measurement
    """

    MAX_PAYLOAD_SIZE = 237  # Meshtastic limit

    def __init__(self, payload: bytes, sender: str, dest: str):
        self.payload = self._validate_payload(payload)
        self.sender = sender
        self.destination = dest
        self.timestamp = time.time()
        self.hop_count = 0
        self.rssi = None  # Received signal strength
        self.snr = None   # Signal-to-noise ratio

    def _validate_payload(self, payload: bytes) -> bytes:
        """Validate payload size for RF transmission."""
        if len(payload) > self.MAX_PAYLOAD_SIZE:
            raise ValueError(
                f"Payload too large for mesh transmission: "
                f"{len(payload)} > {self.MAX_PAYLOAD_SIZE} bytes"
            )
        return payload

    def estimate_airtime(self, spreading_factor: int = 11) -> float:
        """
        Estimate RF airtime for this message.

        Important for duty cycle compliance and
        network capacity planning.
        """
        # LoRa airtime calculation
        # Simplified - actual depends on bandwidth, coding rate
        symbols = 8 + max(
            math.ceil((8 * len(self.payload) - 4 * spreading_factor + 28)
                     / (4 * spreading_factor)) * 5,
            0
        )
        symbol_time = (2 ** spreading_factor) / 125000  # 125kHz bandwidth
        return symbols * symbol_time
```

---

## Part 2: AI Debugging Methodology

### 2.1 Systematic Error Analysis

```
AI DEBUGGING WORKFLOW
═════════════════════

1. ERROR CLASSIFICATION
   ├── Syntax Errors → Direct fix
   ├── Runtime Errors → Trace analysis
   ├── Logic Errors → Behavior comparison
   ├── Resource Errors → System state check
   └── Network Errors → Protocol analysis

2. ROOT CAUSE ANALYSIS
   ├── Read full error message
   ├── Examine stack trace
   ├── Check recent changes
   ├── Review related code
   └── Test in isolation

3. FIX VERIFICATION
   ├── Unit tests pass
   ├── Integration tests pass
   ├── No new warnings
   ├── Performance maintained
   └── Security unchanged
```

### 2.2 Debug Patterns for Mesh/RF Systems

```python
# DEBUGGING TOOLS FOR MESH NETWORKS

import logging
from dataclasses import dataclass
from typing import Optional, List
from datetime import datetime

# Configure detailed logging for debugging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s | %(name)s | %(levelname)s | %(message)s',
    handlers=[
        logging.FileHandler('meshforge_debug.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('meshforge.debug')


@dataclass
class DebugTrace:
    """Structured debug information for analysis."""
    timestamp: datetime
    component: str
    operation: str
    input_data: dict
    output_data: Optional[dict]
    error: Optional[str]
    duration_ms: float
    rf_metrics: Optional[dict] = None


class MeshDebugger:
    """
    Comprehensive debugging tool for mesh network issues.

    Captures RF metrics, timing, and protocol state
    for systematic problem analysis.
    """

    def __init__(self):
        self.traces: List[DebugTrace] = []
        self.error_patterns = {}

    def trace_operation(self, component: str, operation: str):
        """Decorator for tracing operations."""
        def decorator(func):
            def wrapper(*args, **kwargs):
                start = time.time()
                input_data = {'args': str(args), 'kwargs': str(kwargs)}

                try:
                    result = func(*args, **kwargs)
                    duration = (time.time() - start) * 1000

                    trace = DebugTrace(
                        timestamp=datetime.now(),
                        component=component,
                        operation=operation,
                        input_data=input_data,
                        output_data={'result': str(result)},
                        error=None,
                        duration_ms=duration
                    )
                    self.traces.append(trace)

                    # Log slow operations
                    if duration > 1000:
                        logger.warning(
                            f"Slow operation: {component}.{operation} "
                            f"took {duration:.2f}ms"
                        )

                    return result

                except Exception as e:
                    duration = (time.time() - start) * 1000
                    trace = DebugTrace(
                        timestamp=datetime.now(),
                        component=component,
                        operation=operation,
                        input_data=input_data,
                        output_data=None,
                        error=str(e),
                        duration_ms=duration
                    )
                    self.traces.append(trace)
                    self._analyze_error(e, component, operation)
                    raise

            return wrapper
        return decorator

    def _analyze_error(self, error: Exception, component: str, operation: str):
        """Analyze error patterns for debugging insights."""
        error_type = type(error).__name__
        key = f"{component}.{operation}.{error_type}"

        if key not in self.error_patterns:
            self.error_patterns[key] = {
                'count': 0,
                'first_seen': datetime.now(),
                'last_seen': None,
                'samples': []
            }

        pattern = self.error_patterns[key]
        pattern['count'] += 1
        pattern['last_seen'] = datetime.now()

        if len(pattern['samples']) < 5:
            pattern['samples'].append(str(error))

        # Alert on recurring errors
        if pattern['count'] == 5:
            logger.error(
                f"Recurring error detected: {key} "
                f"occurred 5 times since {pattern['first_seen']}"
            )

    def diagnose_connectivity(self, node_id: str) -> dict:
        """
        Diagnose mesh connectivity issues.

        Returns comprehensive diagnostic information
        for network troubleshooting.
        """
        diagnostics = {
            'node_id': node_id,
            'timestamp': datetime.now().isoformat(),
            'checks': []
        }

        # Check 1: Serial/USB connection
        check = self._check_serial_connection(node_id)
        diagnostics['checks'].append(check)

        # Check 2: Node response
        check = self._check_node_response(node_id)
        diagnostics['checks'].append(check)

        # Check 3: RF reception
        check = self._check_rf_reception(node_id)
        diagnostics['checks'].append(check)

        # Check 4: Mesh routing
        check = self._check_mesh_routing(node_id)
        diagnostics['checks'].append(check)

        # Generate summary
        failed = [c for c in diagnostics['checks'] if not c['passed']]
        diagnostics['status'] = 'healthy' if not failed else 'issues_found'
        diagnostics['issues'] = [c['issue'] for c in failed if c.get('issue')]

        return diagnostics

    def generate_debug_report(self) -> str:
        """Generate comprehensive debug report."""
        report = []
        report.append("=" * 60)
        report.append("MESHFORGE DEBUG REPORT")
        report.append("=" * 60)
        report.append(f"Generated: {datetime.now().isoformat()}")
        report.append(f"Total traces: {len(self.traces)}")
        report.append("")

        # Error summary
        if self.error_patterns:
            report.append("-" * 60)
            report.append("ERROR PATTERNS")
            report.append("-" * 60)
            for key, pattern in self.error_patterns.items():
                report.append(f"\n{key}:")
                report.append(f"  Count: {pattern['count']}")
                report.append(f"  First seen: {pattern['first_seen']}")
                report.append(f"  Last seen: {pattern['last_seen']}")

        # Slow operations
        slow_ops = [t for t in self.traces if t.duration_ms > 500]
        if slow_ops:
            report.append("")
            report.append("-" * 60)
            report.append("SLOW OPERATIONS")
            report.append("-" * 60)
            for trace in slow_ops[-10:]:
                report.append(
                    f"  {trace.component}.{trace.operation}: "
                    f"{trace.duration_ms:.2f}ms"
                )

        return "\n".join(report)
```

---

## Part 3: Infrastructure & Usability Review

### 3.1 AI Code Review Checklist

```
AI CODE REVIEW FRAMEWORK
════════════════════════

SECURITY REVIEW
□ Input validation on all external data
□ No hardcoded credentials or secrets
□ Proper authentication/authorization
□ SQL injection prevention
□ Command injection prevention
□ Path traversal prevention
□ XSS prevention (if web)
□ Secure communication (TLS/encryption)

QUALITY REVIEW
□ Code follows project style guide
□ Functions have single responsibility
□ No code duplication (DRY)
□ Proper error handling
□ Meaningful variable names
□ Adequate documentation
□ Type hints where applicable

PERFORMANCE REVIEW
□ No unnecessary loops
□ Efficient data structures
□ Proper resource cleanup
□ Async where beneficial
□ Caching implemented appropriately
□ Database queries optimized

MESH/RF SPECIFIC REVIEW
□ Payload sizes appropriate for LoRa
□ Duty cycle considered
□ Channel usage appropriate
□ Retransmission logic sound
□ Timeout values reasonable
□ Signal metrics captured

USABILITY REVIEW
□ Clear error messages
□ Helpful logging
□ Intuitive API
□ Good defaults
□ Configuration documented
□ Examples provided
```

### 3.2 Architecture Review Patterns

```python
# INFRASTRUCTURE REVIEW TOOLS

from dataclasses import dataclass
from typing import List, Dict, Optional
from enum import Enum
import ast
import re


class ReviewSeverity(Enum):
    """Review finding severity levels."""
    CRITICAL = "critical"  # Must fix before deploy
    HIGH = "high"          # Should fix soon
    MEDIUM = "medium"      # Plan to fix
    LOW = "low"            # Nice to fix
    INFO = "info"          # Informational


@dataclass
class ReviewFinding:
    """A single code review finding."""
    file: str
    line: Optional[int]
    severity: ReviewSeverity
    category: str
    message: str
    suggestion: Optional[str]


class AICodeReviewer:
    """
    Automated code review assistant.

    Analyzes code for security, quality, performance,
    and mesh-specific considerations.
    """

    SECURITY_PATTERNS = {
        r'shell\s*=\s*True': (
            ReviewSeverity.CRITICAL,
            "Shell=True with user input is dangerous",
            "Use shell=False and pass args as list"
        ),
        r'eval\s*\(': (
            ReviewSeverity.CRITICAL,
            "eval() is dangerous with untrusted input",
            "Use ast.literal_eval() for data parsing"
        ),
        r'exec\s*\(': (
            ReviewSeverity.CRITICAL,
            "exec() is dangerous with untrusted input",
            "Find alternative approach without exec"
        ),
        r'pickle\.loads?\s*\(': (
            ReviewSeverity.HIGH,
            "pickle is unsafe with untrusted data",
            "Use JSON for untrusted data serialization"
        ),
        r'password\s*=\s*["\'][^"\']+["\']': (
            ReviewSeverity.CRITICAL,
            "Hardcoded password detected",
            "Use environment variables or secure vault"
        ),
        r'api_key\s*=\s*["\'][^"\']+["\']': (
            ReviewSeverity.CRITICAL,
            "Hardcoded API key detected",
            "Use environment variables"
        ),
    }

    QUALITY_PATTERNS = {
        r'except\s*:': (
            ReviewSeverity.MEDIUM,
            "Bare except catches all exceptions",
            "Catch specific exceptions"
        ),
        r'# ?TODO': (
            ReviewSeverity.LOW,
            "TODO comment found",
            "Consider resolving or creating issue"
        ),
        r'print\s*\(': (
            ReviewSeverity.LOW,
            "print() statement found",
            "Use logging for production code"
        ),
    }

    MESH_PATTERNS = {
        r'time\.sleep\s*\(\s*\d{2,}\s*\)': (
            ReviewSeverity.MEDIUM,
            "Long sleep may cause missed messages",
            "Use async/event-based waiting"
        ),
        r'payload.*["\'].{250,}["\']': (
            ReviewSeverity.HIGH,
            "Large payload may exceed LoRa limits",
            "Check MAX_PAYLOAD_SIZE before sending"
        ),
    }

    def review_file(self, filepath: str) -> List[ReviewFinding]:
        """Review a single file."""
        findings = []

        with open(filepath, 'r') as f:
            content = f.read()
            lines = content.split('\n')

        # Pattern-based checks
        all_patterns = {
            **self.SECURITY_PATTERNS,
            **self.QUALITY_PATTERNS,
            **self.MESH_PATTERNS
        }

        for line_num, line in enumerate(lines, 1):
            for pattern, (severity, message, suggestion) in all_patterns.items():
                if re.search(pattern, line, re.IGNORECASE):
                    findings.append(ReviewFinding(
                        file=filepath,
                        line=line_num,
                        severity=severity,
                        category="security" if pattern in self.SECURITY_PATTERNS else "quality",
                        message=message,
                        suggestion=suggestion
                    ))

        # AST-based checks for Python files
        if filepath.endswith('.py'):
            findings.extend(self._ast_review(content, filepath))

        return findings

    def _ast_review(self, content: str, filepath: str) -> List[ReviewFinding]:
        """Perform AST-based code analysis."""
        findings = []

        try:
            tree = ast.parse(content)
        except SyntaxError as e:
            findings.append(ReviewFinding(
                file=filepath,
                line=e.lineno,
                severity=ReviewSeverity.CRITICAL,
                category="syntax",
                message=f"Syntax error: {e.msg}",
                suggestion=None
            ))
            return findings

        for node in ast.walk(tree):
            # Check for functions without docstrings
            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                if not ast.get_docstring(node):
                    findings.append(ReviewFinding(
                        file=filepath,
                        line=node.lineno,
                        severity=ReviewSeverity.LOW,
                        category="documentation",
                        message=f"Function '{node.name}' missing docstring",
                        suggestion="Add docstring describing purpose and parameters"
                    ))

            # Check for classes without docstrings
            if isinstance(node, ast.ClassDef):
                if not ast.get_docstring(node):
                    findings.append(ReviewFinding(
                        file=filepath,
                        line=node.lineno,
                        severity=ReviewSeverity.LOW,
                        category="documentation",
                        message=f"Class '{node.name}' missing docstring",
                        suggestion="Add docstring describing class purpose"
                    ))

        return findings

    def generate_review_report(self, findings: List[ReviewFinding]) -> str:
        """Generate formatted review report."""
        report = []
        report.append("=" * 60)
        report.append("AI CODE REVIEW REPORT")
        report.append("=" * 60)

        # Summary by severity
        by_severity = {}
        for f in findings:
            by_severity.setdefault(f.severity, []).append(f)

        report.append("\nSUMMARY")
        report.append("-" * 40)
        for severity in ReviewSeverity:
            count = len(by_severity.get(severity, []))
            if count > 0:
                report.append(f"  {severity.value.upper()}: {count}")

        # Detailed findings
        report.append("\n" + "=" * 60)
        report.append("FINDINGS")
        report.append("=" * 60)

        for severity in [ReviewSeverity.CRITICAL, ReviewSeverity.HIGH,
                        ReviewSeverity.MEDIUM, ReviewSeverity.LOW]:
            if severity in by_severity:
                report.append(f"\n[{severity.value.upper()}]")
                report.append("-" * 40)
                for finding in by_severity[severity]:
                    report.append(f"\nFile: {finding.file}:{finding.line}")
                    report.append(f"Issue: {finding.message}")
                    if finding.suggestion:
                        report.append(f"Fix: {finding.suggestion}")

        return "\n".join(report)
```

---

## Part 4: AI Assistant Integration

### 4.1 Assistant Context Protocol

```python
# AI ASSISTANT CONTEXT PROTOCOL

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
from datetime import datetime
import json


@dataclass
class ProjectContext:
    """
    Complete project context for AI assistant.

    Provides all information an AI needs to
    effectively assist with development.
    """

    # Project metadata
    name: str
    version: str
    description: str

    # Technology stack
    languages: List[str]
    frameworks: List[str]
    dependencies: Dict[str, str]

    # Domain knowledge
    domain: str  # e.g., "mesh_networking"
    key_concepts: List[str]

    # Coding standards
    style_guide: Optional[str]
    conventions: Dict[str, str]

    # Security requirements
    security_level: str  # low, medium, high, critical
    compliance_requirements: List[str]

    # Current task context
    current_file: Optional[str] = None
    current_function: Optional[str] = None
    recent_changes: List[str] = field(default_factory=list)
    known_issues: List[str] = field(default_factory=list)


@dataclass
class AssistantSession:
    """
    AI assistant session state.

    Tracks conversation history, decisions made,
    and code generated for coherent assistance.
    """

    session_id: str
    started: datetime
    context: ProjectContext

    # Conversation tracking
    messages: List[Dict[str, str]] = field(default_factory=list)
    decisions: List[Dict[str, Any]] = field(default_factory=list)

    # Code tracking
    code_generated: List[Dict[str, str]] = field(default_factory=list)
    code_reviewed: List[str] = field(default_factory=list)

    # Learning/adaptation
    user_preferences: Dict[str, Any] = field(default_factory=dict)
    corrections_received: List[Dict[str, str]] = field(default_factory=list)

    def add_message(self, role: str, content: str):
        """Add message to conversation history."""
        self.messages.append({
            'timestamp': datetime.now().isoformat(),
            'role': role,
            'content': content
        })

    def record_decision(self, decision: str, reasoning: str, alternatives: List[str]):
        """Record a technical decision made during session."""
        self.decisions.append({
            'timestamp': datetime.now().isoformat(),
            'decision': decision,
            'reasoning': reasoning,
            'alternatives': alternatives
        })

    def record_code(self, filename: str, code: str, purpose: str):
        """Record code generated during session."""
        self.code_generated.append({
            'timestamp': datetime.now().isoformat(),
            'filename': filename,
            'code': code,
            'purpose': purpose
        })

    def receive_correction(self, original: str, corrected: str, explanation: str):
        """Learn from user correction."""
        self.corrections_received.append({
            'timestamp': datetime.now().isoformat(),
            'original': original,
            'corrected': corrected,
            'explanation': explanation
        })

    def export_session(self) -> str:
        """Export session for analysis or continuation."""
        return json.dumps({
            'session_id': self.session_id,
            'started': self.started.isoformat(),
            'context': {
                'name': self.context.name,
                'domain': self.context.domain,
            },
            'statistics': {
                'messages': len(self.messages),
                'decisions': len(self.decisions),
                'code_generated': len(self.code_generated),
                'corrections': len(self.corrections_received)
            },
            'decisions': self.decisions,
            'code_generated': self.code_generated
        }, indent=2)
```

### 4.2 MeshForge-Specific AI Context

```python
# MESHFORGE AI CONTEXT TEMPLATE

MESHFORGE_CONTEXT = ProjectContext(
    name="MeshForge",
    version="1.0.0",
    description="LoRa Mesh Network Development & Operations Suite",

    languages=["Python", "JavaScript", "SQL"],
    frameworks=["GTK4", "libadwaita", "asyncio"],
    dependencies={
        "meshtastic": ">=2.0.0",
        "reticulum": ">=0.5.0",
        "PyGObject": ">=3.42",
    },

    domain="mesh_networking",
    key_concepts=[
        "LoRa modulation",
        "Mesh routing protocols",
        "RF propagation",
        "Duty cycle regulations",
        "Amateur radio (Part 97)",
        "AREDN mesh",
        "Reticulum protocol",
        "LXMF messaging",
    ],

    style_guide="PEP 8 with type hints",
    conventions={
        "naming": "snake_case for functions, PascalCase for classes",
        "docstrings": "Google style",
        "imports": "isort configuration",
        "formatting": "black compatible",
    },

    security_level="high",
    compliance_requirements=[
        "FCC Part 97 (amateur radio)",
        "FCC Part 15 (ISM bands)",
        "GDPR (user data)",
    ]
)
```

---

## Part 5: Educational Integration

### 5.1 Learning Tracks

```
AI DEVELOPMENT UNIVERSITY TRACKS
════════════════════════════════

TRACK 1: AI-Assisted Coding Fundamentals
├── Lesson 1: Understanding AI Code Generation
├── Lesson 2: Prompt Engineering for Code
├── Lesson 3: Review and Validation Techniques
├── Lesson 4: Security Considerations
└── Assessment: Generate and review a mesh utility

TRACK 2: Debugging with AI
├── Lesson 1: Error Analysis Methodology
├── Lesson 2: Using AI for Root Cause Analysis
├── Lesson 3: Mesh/RF Specific Debugging
├── Lesson 4: Performance Optimization
└── Assessment: Debug a failing mesh connection

TRACK 3: Code Review and Quality
├── Lesson 1: Automated Review Patterns
├── Lesson 2: Security Audit Techniques
├── Lesson 3: Performance Review
├── Lesson 4: Documentation Standards
└── Assessment: Review a mesh protocol implementation

TRACK 4: Infrastructure Design
├── Lesson 1: Architecture Patterns
├── Lesson 2: Scalability Considerations
├── Lesson 3: Security Architecture
├── Lesson 4: Mesh Network Design
└── Assessment: Design a multi-node mesh system
```

### 5.2 Assessment Framework

```python
# AI DEVELOPMENT ASSESSMENT SYSTEM

@dataclass
class Assessment:
    """Educational assessment for AI development skills."""

    id: str
    title: str
    track: str
    difficulty: str  # beginner, intermediate, advanced

    # Assessment components
    scenario: str
    requirements: List[str]
    evaluation_criteria: Dict[str, int]  # criterion -> max points

    # AI interaction allowed
    ai_assistance_level: str  # none, guided, full


class AssessmentEvaluator:
    """Evaluates student submissions for AI development assessments."""

    def evaluate_code_submission(
        self,
        assessment: Assessment,
        code: str
    ) -> Dict[str, Any]:
        """Evaluate a code submission."""
        results = {
            'assessment_id': assessment.id,
            'submitted': datetime.now().isoformat(),
            'scores': {},
            'feedback': [],
            'passed': False
        }

        # Security check
        reviewer = AICodeReviewer()
        findings = reviewer.review_file_content(code)

        critical_findings = [f for f in findings
                           if f.severity == ReviewSeverity.CRITICAL]
        if critical_findings:
            results['scores']['security'] = 0
            results['feedback'].append(
                "Critical security issues found - must fix before passing"
            )
        else:
            results['scores']['security'] = assessment.evaluation_criteria.get('security', 0)

        # Quality check
        # ... additional evaluation logic

        # Calculate total
        total = sum(results['scores'].values())
        max_total = sum(assessment.evaluation_criteria.values())
        results['total_score'] = total
        results['max_score'] = max_total
        results['percentage'] = (total / max_total * 100) if max_total > 0 else 0
        results['passed'] = results['percentage'] >= 70

        return results
```

---

## Appendix: Quick Reference

### Security Checklist
```
□ Input validation
□ Output encoding
□ Authentication
□ Authorization
□ Cryptography
□ Error handling
□ Logging
□ Data protection
```

### Code Quality Checklist
```
□ Single responsibility
□ Clear naming
□ Proper documentation
□ Error handling
□ Test coverage
□ No duplication
□ Efficient algorithms
□ Resource management
```

### Mesh-Specific Checklist
```
□ Payload size limits
□ Duty cycle compliance
□ Channel selection
□ Signal metrics
□ Timeout handling
□ Retry logic
□ Route optimization
□ Network topology
```

---

*MeshForge Security and Code University*
*AI Development Practices Guide v1.0*
